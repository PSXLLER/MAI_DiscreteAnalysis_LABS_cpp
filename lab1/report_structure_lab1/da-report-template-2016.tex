\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{graphicx}
% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

Выполнил студент группы 08-207 МАИ \textit{Дружинин Данила}.

\subsection*{Условие}

\begin{enumerate}
\item Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывод отсортированной последовательности. 


\item Задача AA. $9-3$

Вариант задания определяется типом ключа (и соответствующим ему методом сортировки) и типом значения: Карманная сортировка.

Тип ключа: вещественные числа в промежутке 
$[-100,100]$.

Тип значения: числа от $0$ до $2^{64}$ $-$ $1$
\end{enumerate}

\subsection*{Метод решения}

Я реализовал алгоритм карманной сортировки (Bucket Sort), обеспечивающий линейное время работы при равномерном распределении входных данных.

Суть данного алгоритма заключается в разбиении исходного диапазона значений ключа на фиксированное количество интервалов. Каждый элемент входной последовательности распределяется в соответствующий карман в зависимости от значения ключа. После распределения элементы внутри каждого кармана упорядочиваются, а затем карманы последовательно объединяются, формируя итоговую отсортированную последовательность.

В данной задаче диапазон ключей ограничен интервалом 
$[-100,100]$. Этот интервал разбивается на заранее заданное количество карманов одинаковой ширины. Индекс кармана вычисляется по формуле:
\[
i = \left\lfloor \frac{x - a}{b - a} \cdot m \right\rfloor,
\]
где \(x\) — значение ключа, \(a\) и \(b\) — границы диапазона, \(m\) — количество карманов.

Для хранения данных реализован собственный динамический массив (класс TVector), работающий по принципу автоматического увеличения ёмкости при переполнении. Увеличение размера массива происходит по схеме удвоения текущей ёмкости.

Сортировка элементов внутри каждого кармана выполняется методом сортировки вставками (Insertion Sort), что эффективно при малом количестве элементов в каждом кармане.

Итоговая сложность алгоритма составляет $O(n+k)$, где $n$ --- количество элементов, $k$ --- количество карманов. При равномерном распределении входных данных алгоритм работает за линейное время.

Ввод данных осуществляется из стандартного потока ввода, вывод — в стандартный поток вывода.
\subsection*{Описание программы}

Программа реализована на языке C++ и состоит из одного исходного файла. 

\vspace{\baselineskip}
\textbf{Структура программы}

\begin{enumerate}
	\item \textbf{Структура \texttt{TKeyValuePair}.}  
	
	Используется для хранения пары «ключ--значение».  
	Поле \texttt{Key} имеет тип \texttt{double}, поле \texttt{Value} --- тип \texttt{unsigned long long}.
	
	\item \textbf{Класс \texttt{TVector}.}  
	
	Реализует динамический массив для хранения элементов типа \texttt{TKeyValuePair}.  
	Класс содержит:
	\begin{itemize}
		\item поле \texttt{Size} --- текущее количество элементов,
		\item поле \texttt{Capacity} --- текущую ёмкость массива,
		\item указатель \texttt{Data} --- динамически выделенный массив элементов.
	\end{itemize}
	При переполнении массива выполняется увеличение ёмкости в два раза 
	(метод \texttt{Resize}). Добавление элемента осуществляется методом \texttt{PushBack}.
	
	\item \textbf{Функция \texttt{InsertionSort}.}  
	
	Выполняет сортировку элементов внутри одного кармана методом сортировки вставками.  
	Применяется к каждому непустому карману после распределения элементов.
	
	\item \textbf{Функция \texttt{BucketSort}.}  
	
	Реализует алгоритм карманной сортировки:
	\begin{enumerate}
		\item создаётся массив карманов,
		\item элементы распределяются по карманам в зависимости от значения ключа,
		\item элементы внутри каждого кармана сортируются,
		\item карманы последовательно объединяются в итоговую последовательность.
	\end{enumerate}
	
	\item \textbf{Функция \texttt{main}.}  
	
	Выполняет чтение входных данных из стандартного потока ввода, 
	вызов функции сортировки и вывод отсортированных данных в стандартный поток вывода.
\end{enumerate}

\textbf{Логика работы программы}

\begin{enumerate}
	\item Чтение входных данных до достижения конца входного потока.
	\item Вычисление ширины кармана на основе заданного диапазона ключей.
	\item Распределение элементов по карманам.
	\item Локальная сортировка элементов внутри каждого кармана.
	\item Формирование итоговой упорядоченной последовательности.
	\item Вывод результата в требуемом формате.
\end{enumerate} 

\subsection*{Дневник отладки}

В ходе выполнения лабораторной работы в код было внесено много изменений и исправлений. В основном действия касались трёх аспектов: корректности алгоритма, устойчивости вычислений и строгого соблюдения формата вывода.

\vspace{\baselineskip}
\textbf{1. Проблемы формата ввода-вывода.}

\vspace{\baselineskip}
Изначально программа использовала перенаправление потоков через \texttt{freopen}. Локально это работало корректно, однако в системе тестирования возникали ошибки WA.

После удаления \texttt{freopen} программа была переведена на \texttt{std::cin / std::cout}. Далее возникли расхождения в формате вывода (лишние пробелы, различие между пробелом и табуляцией, неточное количество знаков после запятой). Для устранения этих проблем потоковый вывод был заменён на форматированный вывод через \texttt{printf}, что позволило строго задать формат:
\[
\texttt{\%.*f}
\]
с фиксированной точностью.

\vspace{\baselineskip}
\textbf{2. Ошибка в вычислении индекса кармана.}
\vspace{\baselineskip}

В ранней версии индекс кармана вычислялся через нормализацию:

\[
\text{index} = \left( \frac{x - a}{b - a} \right) \cdot (m - 1).
\]

На практике при \(x = b\) из-за особенностей представления числа типа \texttt{double} выражение могло давать значение, немного превышающее 1, что приводило к выходу индекса за границы массива. Это проявлялось на граничных тестах.

Для повышения численной устойчивости формула была переписана в эквивалентной, но более контролируемой форме:

\[
\text{bucketWidth} = \frac{b - a}{m},
\quad
\text{index} = \left\lfloor \frac{x - a}{\text{bucketWidth}} \right\rfloor.
\]

Дополнительно была введена явная проверка границ индекса. Это гарантировало корректное распределение элементов даже при погрешностях округления.

\vspace{\baselineskip}
\textbf{3. Выбор количества карманов.}
\vspace{\baselineskip}

В начальной версии использовалось относительно небольшое количество карманов (1000). Это приводило к высокой плотности элементов внутри отдельных карманов. Поскольку внутри кармана применяется сортировка вставками, в худшем случае это ухудшало асимптотику до квадратичной внутри отдельных сегментов.

Количество карманов было увеличено для более равномерного распределения элементов по диапазону. Это позволило приблизить практическую сложность к ожидаемой \(O(n + m)\) и уменьшить нагрузку на локальную сортировку.

\vspace{\baselineskip}
\textbf{4. Структурные упрощения.}
\vspace{\baselineskip}

Первоначально использовались:
\begin{itemize}
	\item пространство имён,
	\item шаблонный класс вектора,
\end{itemize}

Эти элементы не влияли на корректность алгоритма, но усложняли анализ кода и потенциально затрудняли проверку стилевых требований. В финальной версии код был упрощён до минимально необходимой структуры с сохранением всей логики алгоритма.

\vspace{\baselineskip}
\textbf{5. Технические ошибки.}
\vspace{\baselineskip}

В процессе отладки были устранены:
\begin{itemize}
	\item пропущенная фигурная скобка в функции \texttt{main},
	\item неточности в вычислении границ диапазона.
\end{itemize}

После внесения всех исправлений программа:
\begin{itemize}
	\item корректно распределяет элементы по карманам по формуле
	\( i = \left\lfloor \frac{x-a}{b-a} \cdot m \right\rfloor \),
	\item устойчива к граничным значениям диапазона,
	\item соблюдает требуемый формат вывода,
	\item демонстрирует линейную сложность при равномерном распределении входных данных.
\end{itemize}

\subsection*{Тест производительности}

Для оценки практической сложности алгоритма были проведены замеры времени работы программы при различных объёмах входных данных от 1 до 15 миллионов элементов. Данные генерировались равномерно в диапазоне $[-100,100]$. При проведении измерений вывод отсортированной последовательности отключался, поскольку операции ввода-вывода существенно искажают результаты замера времени.

Результаты измерений показали устойчивый рост времени выполнения при увеличении количества элементов. Для наглядности зависимость времени работы от объёма входных данных представлена на графике (рис.~\ref{fig:performance}).

\begin{figure}[h]
	\centering
	\includegraphics[width=0.75\linewidth]{performance.png}
	\caption{Зависимость времени работы карманной сортировки от количества элементов (1–15 млн)}
	\label{fig:performance}
\end{figure}

Как видно из графика, рост времени выполнения имеет практически линейный характер. Небольшие отклонения от идеальной прямой объясняются особенностями работы динамической памяти, влиянием кэширования процессора и неравномерностью распределения элементов по карманам. Тем не менее общий тренд подтверждает, что при фиксированном числе карманов алгоритм демонстрирует поведение, близкое к линейной сложности.

Экспериментально подтверждается соответствие практического времени работы теоретической оценке $O(n + m)$. Поскольку число карманов $m$ фиксировано, доминирующей становится линейная часть $O(n)$..


\subsection*{Недочёты}

Несмотря на корректную работу программы, в реализации присутствуют
некоторые технические упрощения и компромиссы.

Во-первых, для обработки граничных случаев используется явная проверка
выхода индекса кармана за пределы допустимого диапазона:

\[
\text{if (index >= BUCKETS\_COUNT) index = BUCKETS\_COUNT - 1;}
\]

Данная проверка добавлена для защиты от погрешностей представления
вещественных чисел типа \texttt{double}. Формально при точных вычислениях
выход за границы происходить не должен, однако на практике возможны
округления. Это решение является защитным механизмом и упрощает
обработку граничных случаев.

Во-вторых, число карманов задаётся фиксированной константой.
Оптимальным с точки зрения теории было бы выбирать число карманов
в зависимости от объёма входных данных, однако в рамках лабораторной
работы выбрано фиксированное значение, обеспечивающее приемлемую
производительность при тестируемых размерах входа.
Адаптивный выбор числа карманов не реализован
для сохранения простоты алгоритма.

Внутри каждого кармана используется сортировка вставками.
При крайне неравномерном распределении данных это может привести
к ухудшению производительности вплоть до квадратичного поведения
внутри отдельного кармана. В рамках задания предполагается
равномерное распределение ключей, поэтому более сложные методы
локальной сортировки не применялись.

С точки зрения производительности следует отметить,
что реализация активно использует динамическое выделение памяти
(создание массива карманов и расширение внутренних массивов).
При очень больших объёмах данных это может приводить
к дополнительным накладным расходам времени
из-за операций выделения и освобождения памяти.
Более оптимизированная версия могла бы заранее резервировать
память или использовать пул памяти,
однако такие усложнения не требовались условиями работы.

Также алгоритм требует дополнительную память
размером $O(n + m)$:
помимо исходного массива создаётся массив карманов,
каждый из которых содержит собственный динамический массив.
При больших значениях $n$ это увеличивает общее потребление памяти.
Тем не менее в рамках тестируемых объёмов входных данных
память использовалась в допустимых пределах.

Перечисленные ограничения являются осознанными компромиссами,
не влияющими на корректность работы программы
и не нарушающими требований лабораторной работы.

\subsection*{Выводы}

В рамках лабораторной работы была реализована карманная сортировка
для упорядочивания пар «ключ–значение» по вещественному ключу
в фиксированном диапазоне. Алгоритм эффективен при обработке
больших массивов данных с равномерным распределением ключей,
так как в среднем демонстрирует линейную временную сложность $O(n)$.

Область применения данного алгоритма связана с задачами,
где заранее известен диапазон значений ключей и допускается
использование дополнительной памяти.
Типовыми примерами являются предварительная обработка числовых данных,
сортировка результатов вычислений, обработка статистических выборок
и других структур, где требуется быстрая сортировка большого объёма
вещественных значений.

С точки зрения сложности программирования задача оказалась
не тривиальной. Основные трудности были связаны с корректным
вычислением индекса кармана, обработкой граничных значений диапазона,
а также обеспечением строгого соответствия формату ввода и вывода.
Дополнительные сложности возникли при реализации собственного
динамического массива без использования стандартных контейнеров.

В ходе работы удалось проанализировать особенности численных
вычислений с плавающей точкой, влияние распределения данных
на производительность алгоритма и соотношение между временем
работы и объёмом используемой памяти.

Таким образом, поставленная задача была решена,
а полученная реализация демонстрирует ожидаемую
линейную зависимость времени работы от объёма входных данных
при выполнении предположений о равномерности распределения ключей.
\end{document}

